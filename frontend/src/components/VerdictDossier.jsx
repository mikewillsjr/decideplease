import { useState } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import rehypeSanitize from 'rehype-sanitize';
import Stage1 from './Stage1';
import Stage1_5 from './Stage1_5';
import Stage2 from './Stage2';
import './VerdictDossier.css';

/**
 * Mode display info - maps mode to human-readable stages
 */
const MODE_INFO = {
  // New mode names
  quick_decision: { label: 'Quick Decision', stages: '1 → 3', description: 'Fast answer with Haiku-tier models' },
  decide_please: { label: 'Decide Please', stages: '1 → 2 → 3', description: 'Full peer review' },
  decide_pretty_please: { label: 'Decide Pretty Please', stages: '1 → 1.5 → 2 → 3', description: 'Cross-review + peer review' },
  // Legacy mode names (for backward compatibility)
  quick: { label: 'Quick Decision', stages: '1 → 3', description: 'Fast answer with Haiku-tier models' },
  standard: { label: 'Decide Please', stages: '1 → 2 → 3', description: 'Full peer review' },
  extra_care: { label: 'Decide Pretty Please', stages: '1 → 1.5 → 2 → 3', description: 'Cross-review + peer review' },
};

/**
 * Verdict Dossier - Shows the final answer with modal access to all stages.
 * Features: remark-gfm for tables, sticky supplement area, mode indicator.
 */
export default function VerdictDossier({
  question,
  stage1,
  stage1_5,
  stage2,
  stage3,
  metadata = {},
  isLoading = false,
  children, // For the Supplement component
}) {
  const [showDeliberation, setShowDeliberation] = useState(false);
  const [activeTab, setActiveTab] = useState('stage1');
  const [copyFeedback, setCopyFeedback] = useState(false);

  const {
    aggregate_rankings: aggregateRankings,
    label_to_model: labelToModel,
    stage2Skipped,
    stage1_5Skipped,
    mode = 'decide_please',
  } = metadata;

  const stage3Content = stage3?.response || '';
  const isStreaming = stage3?.streaming === true;
  const hasStage1 = stage1 && stage1.length > 0;
  const hasStage1_5 = stage1_5 && stage1_5.length > 0 && !stage1_5Skipped;
  const hasStage2 = stage2 && stage2.length > 0 && !stage2Skipped;
  const modeInfo = MODE_INFO[mode] || MODE_INFO.decide_please;

  // Determine which tabs to show
  const tabs = [];
  if (hasStage1) tabs.push({ id: 'stage1', label: 'Individual Responses', count: stage1.length });
  if (hasStage1_5) tabs.push({ id: 'stage1_5', label: 'Cross-Review', count: stage1_5.length });
  if (hasStage2) tabs.push({ id: 'stage2', label: 'Peer Rankings', count: stage2.length });

  const handleCopy = async () => {
    const text = `QUESTION:\n${question}\n\nDECISION:\n${stage3Content}`;
    await navigator.clipboard.writeText(text);
    setCopyFeedback(true);
    setTimeout(() => setCopyFeedback(false), 2000);
  };

  const handlePDF = async () => {
    try {
      const { default: jsPDF } = await import('jspdf');
      const doc = new jsPDF();

      const pageWidth = doc.internal.pageSize.getWidth();
      const pageHeight = doc.internal.pageSize.getHeight();
      const margin = 20;
      const maxWidth = pageWidth - margin * 2;
      let y = margin;

      // Title
      doc.setFontSize(14);
      doc.setFont('helvetica', 'bold');
      doc.text('COUNCIL VERDICT', margin, y);
      y += 10;

      // Question
      doc.setFontSize(10);
      doc.setFont('helvetica', 'normal');
      doc.setTextColor(100);
      doc.text('QUERY:', margin, y);
      y += 6;

      doc.setTextColor(0);
      const questionLines = doc.splitTextToSize(question, maxWidth);
      doc.text(questionLines, margin, y);
      y += questionLines.length * 5 + 10;

      // Divider
      doc.setDrawColor(200);
      doc.line(margin, y, pageWidth - margin, y);
      y += 10;

      // Decision
      doc.setFontSize(10);
      doc.setTextColor(100);
      doc.text('DECISION:', margin, y);
      y += 6;

      doc.setTextColor(0);
      const contentLines = doc.splitTextToSize(stage3Content, maxWidth);

      // Handle pagination
      for (const line of contentLines) {
        if (y > pageHeight - margin) {
          doc.addPage();
          y = margin;
        }
        doc.text(line, margin, y);
        y += 5;
      }

      // Footer
      doc.setFontSize(8);
      doc.setTextColor(150);
      doc.text('Generated by DecidePlease', margin, pageHeight - 10);

      // Save
      const filename = `decision-${Date.now()}.pdf`;
      doc.save(filename);
    } catch (error) {
      console.error('Failed to generate PDF:', error);
    }
  };

  return (
    <div className={`verdict-dossier ${isLoading ? 'loading' : ''}`}>
      {/* Question at the top */}
      {question && (
        <div className="verdict-question">
          <div className="question-text">{question}</div>
        </div>
      )}

      {/* Scrollable response area */}
      <div className="verdict-scroll-area">
        <div className="verdict-response">
          {isLoading && !stage3Content ? (
            <div className="loading-skeleton">
              <div className="skeleton-line wide" />
              <div className="skeleton-line medium" />
              <div className="skeleton-line wide" />
              <div className="skeleton-line short" />
            </div>
          ) : stage3Content ? (
            <div className={`markdown-content ${isStreaming ? 'streaming' : ''}`}>
              <ReactMarkdown remarkPlugins={[remarkGfm]} rehypePlugins={[rehypeSanitize]}>{stage3Content}</ReactMarkdown>
              {isStreaming && <span className="streaming-cursor">|</span>}
            </div>
          ) : (
            <p className="awaiting">Awaiting council verdict...</p>
          )}
        </div>
      </div>

      {/* Actions bar - only show when we have content and not streaming */}
      {stage3Content && !isLoading && !isStreaming && (
        <div className="verdict-actions-bar">
          {/* Mode indicator */}
          <div className="mode-indicator" title={modeInfo.description}>
            <span className="mode-label">{modeInfo.label}</span>
            <span className="mode-stages">Stages {modeInfo.stages}</span>
          </div>

          {/* Action buttons */}
          <div className="action-buttons">
            {tabs.length > 0 && (
              <button
                className="action-btn deliberation-btn"
                onClick={() => setShowDeliberation(true)}
                title="View how the council deliberated"
              >
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                  <circle cx="12" cy="12" r="10" />
                  <path d="M12 16v-4M12 8h.01" />
                </svg>
                View Deliberation
              </button>
            )}

            <button
              className="action-btn"
              onClick={handleCopy}
              title="Copy to clipboard"
            >
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                {copyFeedback ? (
                  <path d="M20 6L9 17l-5-5" />
                ) : (
                  <>
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2" />
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" />
                  </>
                )}
              </svg>
              {copyFeedback ? 'Copied!' : 'Copy'}
            </button>

            <button
              className="action-btn"
              onClick={handlePDF}
              title="Download as PDF"
            >
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" />
                <polyline points="14 2 14 8 20 8" />
                <line x1="12" y1="18" x2="12" y2="12" />
                <line x1="9" y1="15" x2="15" y2="15" />
              </svg>
              PDF
            </button>
          </div>
        </div>
      )}

      {/* Sticky supplement area */}
      {children && (
        <div className="verdict-supplement-area">
          {children}
        </div>
      )}

      {/* Deliberation Modal */}
      {showDeliberation && (
        <div className="deliberation-modal-overlay" onClick={() => setShowDeliberation(false)}>
          <div className="deliberation-modal" onClick={e => e.stopPropagation()}>
            <div className="modal-header">
              <h3>Council Deliberation</h3>
              <button className="modal-close" onClick={() => setShowDeliberation(false)}>
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                  <line x1="18" y1="6" x2="6" y2="18" />
                  <line x1="6" y1="6" x2="18" y2="18" />
                </svg>
              </button>
            </div>

            {/* Tab navigation */}
            <div className="modal-tabs">
              {tabs.map(tab => (
                <button
                  key={tab.id}
                  className={`modal-tab ${activeTab === tab.id ? 'active' : ''}`}
                  onClick={() => setActiveTab(tab.id)}
                >
                  {tab.label}
                  <span className="tab-count">{tab.count}</span>
                </button>
              ))}
            </div>

            {/* Tab content */}
            <div className="modal-content">
              {activeTab === 'stage1' && hasStage1 && (
                <Stage1 responses={stage1} />
              )}
              {activeTab === 'stage1_5' && hasStage1_5 && (
                <Stage1_5 responses={stage1_5} originalResponses={stage1} />
              )}
              {activeTab === 'stage2' && hasStage2 && (
                <Stage2
                  rankings={stage2}
                  labelToModel={labelToModel}
                  aggregateRankings={aggregateRankings}
                />
              )}
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
